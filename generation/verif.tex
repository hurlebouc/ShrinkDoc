% !TEX root = ../shrink.tex

\noind On souhaite pouvoir décrire quel est le fonctionnement attendu du programme. On utilise pour cela les résultats des calculs de prédicats au niveau de la syntaxe. On donne un sens à une phrase logique en lui adjuvant un ou plusieurs modèle.

\subsubsection{Syntaxe}

\noind Il est possible d'écrire des phrases mathématique telles que 

$$\forall x \in D, \; \left( P(x) \Rightarrow Q(f(x)) \right)$$

\noind On utilise pour cela la syntaxe du listing \ref{formule}.

\begin{lstlisting}[caption=Définition d'une formule, label=formule]
 Args = ListArgs(Term*)
 
 Term = Var(name:String)
     | Sig(name:String, args:Args)
 
 Formula = Predicate(name:String, args:Args)
        | And(f1:Formula, f2:Formula)
        | Or(f1:Formula, f2:Formula)
        | Imply(f1:Formula, f2:Formula)
        | Not(f:Formula)
        | Forall(var:String, domain:String, f:Formula)
        | Exists(var:String, domain:String, f:Formula)

\end{lstlisting}

\noind La phrase mathématique précédente sera donc sous la forme du listing \ref{f1}.

\begin{lstlisting}[caption=Exemple d'une formule, label=f1, float=htb]
Forall("x",
	"D",
	Imply(
		Predicate(
			"P",
			ListArgs(
				Var(
					"x"
				)
			)
		)
		Predicate(
			"Q",
			ListArgs(
				Sig(
					"f",
					ListArgs(
						Var(
							"x"
						)
					)
				)
			)
		)
	)
)
\end{lstlisting}

\noind On peut ainsi essayer de décrire le fonctionnement d'un programme. Une fois la syntaxe écrite, il faut lui donner un sens. En effet, chaque mot qui n'est pas définit dans la grammaire doit l'être par ailleurs. Ainsi, on voudra dire par exemple que la phrase ci-dessus signifie
\begin{center}
\textit{Pour tout entier $x$, $x$ pair implique $x+1$ impair.}
\end{center}

\subsubsection{Semantique}



