% !TEX root = ../shrink.tex

\noind On souhaite pouvoir décrire quel est le fonctionnement attendu du programme. On utilise pour cela les résultats des calculs de prédicats au niveau de la syntaxe. On donne un sens à une phrase logique en lui adjuvant un ou plusieurs modèle. Tout ce qui va être dit dans cette section n'est qu'une mise en commun de notations. Seule la fin de la dernière partie de cette section est utile au sens où elle donne l'implémentation JAVA de la théorie.

\subsubsection{Syntaxe}

\noind Il est possible d'écrire des phrases mathématique telles que 

$$\forall x \in D, \; \left( (P(x)) \Rightarrow (Q(f(x))) \right)$$

\noind Pour formaliser la syntaxe, on se muni d'un ensemble infini $\X$ de symboles de \textit{variables} et un ensemble $\S$ de symboles de signatures. Chaque signature a une \textit{arité}. On peut alors définir la notion de termes de manière inductive :
\begin{itemize}
\item toute variable est un terme,
\item toute signature d'arité 0 est un terme,
\item si $s$ est un symbole de fonction d'arité $n$, et que $t_1, t_2, \dots, t_n$ sont des termes, alors $s(t_1, t_2, \dots, t_n)$ est un terme.
\end{itemize}
L'ensembles de termes est noté $\T$.\\

\noind Enfin, on peut définir, également de manière inductive, l'ensemble $\F$ des formules : étant donné $\P$ un ensemble de symboles de prédicats et $\D$ est un ensemble de symboles de domaines, on a que
\begin{itemize}
\item tout prédicat d'arité 0 est une formule,
\item si $P$ est un symbole de prédicat d'arité $n$, et que $t_1, t_2, \dots, t_n$ sont des termes, alors $P(t_1, t_2, \dots, t_n)$ est un formule,
\item si $F_1$ et $F_2$ sont des formules, alors $(F_1) \and (F_2)$, $(F_1) \or (F_2)$ et $ (F_1) \imply (F_2)$ sont des formules,
\item si $F$ est une formule, $\not{F}$ est une formule,
\item si $f$ est une formule et $D$ un symbole de domaine, $\forall x \in D, \; (F)$ et $\exists x \in D, \; (F)$ sont des formules.\\
\end{itemize}

\noind Cette définition d'une formule se traduit facilement en \gom (listing \ref{formule}). La phrase mathématique précédente sera donc sous la forme du listing \ref{f1}.

\begin{lstlisting}[caption=Définition d'une formule en \gom, label=formule, float]
 Args = ListArgs(Term*)
 
 Term = Var(name:String)
     | Sig(name:String, args:Args)
 
 Formula = Predicate(name:String, args:Args)
        | And(f1:Formula, f2:Formula)
        | Or(f1:Formula, f2:Formula)
        | Imply(f1:Formula, f2:Formula)
        | Not(f:Formula)
        | Forall(var:String, domain:String, f:Formula)
        | Exists(var:String, domain:String, f:Formula)

\end{lstlisting}


\begin{lstlisting}[caption=Exemple d'une formule, label=f1, float=htb]
Forall("x",
	"D",
	Imply(
		Predicate(
			"P",
			ListArgs(
				Var(
					"x"
				)
			)
		)
		Predicate(
			"Q",
			ListArgs(
				Sig(
					"f",
					ListArgs(
						Var(
							"x"
						)
					)
				)
			)
		)
	)
)
\end{lstlisting}

\noind Une fois la syntaxe écrite, il faut lui donner un \textit{sens}. En effet, chaque mot qui n'est pas définit dans la grammaire doit l'être par ailleurs. Ainsi, on voudra dire par exemple que la phrase ci-dessus signifie
\begin{center}
\textit{Pour tout entier $x$, $x$ pair implique $x+1$ impair.}
\end{center}

\subsubsection{Sémantique}

\noind On définit d'abord $\d$ un ensemble de domaines et on pose
$$\forall n \in \N, \; \f_{\d, n} = \displaystyle{\bigcup_{E \in \d^n,F \in \d}} F^{E} \; \mathrm{et} \; \f'_{\d,n} = \displaystyle{\bigcup_{E \in \d^n}} \{0,1\}^{E}.$$

\noind $\f_{\d,n}$ est donc l'ensemble des fonctions d'arité $n$ dont le codomaine et le domaine sont des éléments de $\d$ et de $\d^n$, et $\f'_{\d, n}$ est l'ensemble des fonctions d'arité $n$ de codomaine $\{0,1\}$ et de domaine dans $\d^{n}$.

\noind On peut interpréter une formule syntaxique issue d'un ensemble de signatures $\S$, de prédicats $\P$ et de domaine $\D$ en lui associant une \textit{interprétation} $I$ qui est la connaissance d'un couple $(\d_I, \ent{\cdot}_I)$ où
\begin{itemize}
\item $\d_I$ est un ensemble de domaine
\item $\ent{\cdot}_I$ est une fonction telle que 


$$ \forall s \in \S, \; \ent{s}_I \in \f_{\d_I,n}, \; \mbox{où $s$ est d'arité $n$}$$
$$ \forall P \in \P, \; \ent{P}_I \in \f'_{\d_I, n}, \; \mbox{où $P$ est d'arité $n$}.$$
$$ \forall D \in \D, \; \ent{D}_I \in \d_I.$$

\end{itemize}

\noind Ainsi, si on applique ce formalisme à notre exemple, on a 
\begin{itemize}
\item $\d_I = \{\N\}$
\item $\ent{f}_I : x\in \N \rightarrow x+1 \in \N$
\item $\ent{P}_I : x \in \N \rightarrow 1$ si $x$ est pair et $0$ sinon
\item $\ent{Q}_I : x \in \N \rightarrow 0$ si $x$ est pair et $1$ sinon.\\
\end{itemize}

\noind On a ainsi appliqué une sémantique à notre formule mathématique.

\subsubsection{Évaluation d'une formule}

\noind On va traité ici la question de savoir comment, étant donné une formule et une interprétation, on peut affirmer qu'une formule est \textit{valide} ou non selon l'interprétation, que l'on note $I \valide F$. On introduit alors la notion de \textit{valuation}. 

\noind Une valuation $\sigma$ est une fonction à domaine fini $\{x_1, x_2, \dots,x_n \} \in \X^n$ où les $x_i$ sont deux à deux distinctes, qui associe à chaque $x_i$ un élément de $E \in \d$. L'ensemble des valuation est noté $\Upsilon$. On peut alors évaluer un terme.
\begin{itemize}
\item Si $x$ est un symbole de variable, $\scal{x \vert \sigma}_I = \sigma(x)$.
\item Si $s$ est un symbole de signature d'arité $n$ et $t_1, t_2, \dots, t_n$ sont des termes, 

$$\scal{s(t_1, t_2, \dots,t_n) \vert \sigma}_I = \ent{s}_I\left(\scal{t_1 \vert \sigma}_I, \scal{t_2 \vert \sigma}_I, \dots, \scal{t_n \vert \sigma}_I\right)$$
\end{itemize}

\noind On peut alors définir la validité d'une formule selon l'interprétation $I$ et la valuation $\sigma$, que l'on note $I\valide_\sigma F$. Si $F, F_1, F_2$ sont des formules, $P$ est un symbole de prédicat d'arité $n$ et $t_1, t_2, \dots, t_n$ sont des termes, alors
\begin{itemize}
\item $ I \valide _\sigma P(t_1, t_2, \dots, t_n) \Leftrightarrow \ent{P}_I(\scal{t_1 \vert \sigma}_I, \scal{t_2 \vert \sigma}_I, \dots, \scal{t_n \vert \sigma}_I) = 1$
\item $ I \valide_\sigma \not{F} \Leftrightarrow I \nvalide_\sigma F$
\item $ I \valide_\sigma (F_1) \and (F_2) \Leftrightarrow I \valide_\sigma F_1 \;\mathrm{et}\; I \valide_\sigma F_2$
\item $ I \valide_\sigma (F_1) \or (F_2) \Leftrightarrow I \valide_\sigma F_1 \;\mathrm{ou}\; I \valide_\sigma F_2$
\item $ I \valide_\sigma (F_1) \imply (F_2) \Leftrightarrow I \nvalide_\sigma F_1 \;\mathrm{ou}\; I \valide_\sigma F_2$
\item $ I \valide_\sigma \forall x \in D, (F) \Leftrightarrow \forall a \in \ent{D}_I, I \nvalide_{\sigma_{\{x \leftarrow a\}}} F$
\item $ I \valide_\sigma \exists x \in D, (F) \Leftrightarrow \exists a \in \ent{D}_I, I \nvalide_{\sigma_{\{x \leftarrow a\}}} F$\\
\end{itemize}

\noind On conclue en définissant 

$$ I \valide F \Leftrightarrow \forall \sigma \in \Upsilon, \; I \valide_\sigma F.$$

\noind On sait maintenant dire qu'une formule est valide, dans une certaine interprétation, de manière \textit{empirique}. En effet, la preuve de validité passe ici par l'énumération exhaustive de tous les cas possibles pour une interprétation donnée. On a choisi cette méthode de preuve, car on dispose d'un générateur de variables aléatoires. Comme de toute façon il est rarement possible de tester tous les cas, on part du principe qu'effectuer des tests sur des exemples suffisamment communs et représentatifs suffit pour avoir une assez grande certitude que le programme que l'on tests fonctionne\footnote{Cela s'apparente à une machine de \textit{Monte-Carlo} qui, renvoyant un contre-exemple prouve que le programme est faux, et sinon donne une certaine probabilité que le programme soit juste}.



















